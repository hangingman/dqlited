#!/bin/bash

#
# convert postresql schema to sqlite
#


SELF=$0
ARGS=$@

msg() { echo >&2 $@ ; }
fail() { msg $@ ; exit 1 ; }

# clean returns a "clean" conversion of the postgres file
# it is reused to transform INHERITS statemennt
function clean() {
    [[ -z $filename ]] && fail "file not set"
    [[ -d $filename ]] && fail "file $filename not found"

    cat << EOF
--
-- This is an SQLite "dump" 
-- It was converted from a Postgres dump using the command:
--
--   '${SELF} ${ARGS[*]}'
--
-- Warning: this file was generated, so edit with caution
--
EOF

    cat $filename   | \
	# no DOS line feeds | \
	tr -d $'\r' | \
	# no tabs either \
	tr '\t' ' ' | \
	# we use line feed as a sub for newline, \
	# so make sure none exist beforehand \
	tr -d $'\f' | \
	# remove empty lines \
	tr -s $'\n' | \
	# no 'schema' support \
	sed -e "s/public\.//g" | \
	# unsupported sql commands \
	sed -E "/^(SET|COPY|SELECT pg_catalog|\\\.)/d" | \
	sed -e "s/^CREATE SEQUENCE.*;//g" 	| \
	sed -e "/^ALTER.* OWNER */d" 		| \
	sed -e "/^ALTER SEQUENCE.*/d" 		| \
	sed -e "/^ALTER.* nextval */d" 		| \
	sed -e "/^GRANT .*/d" 			| \
	sed -e "/^REVOKE .*/d" 			| \
	# use primary key \
	sed -e 's/integer DEFAULT nextval.*/integer primary key,/g' | \
	# capture midstream to compare \
	#tee alter.sql | \
	# adjust datatypes \
	sed -e "s/character varying[^ ,]*/text/" | \
	sed -e "s/ varying/ /g" 		| \
	sed -e "s/timestamp without time zone DEFAULT now()/DaTETIME DEFAULT (datetime('now','utc'))/g" | \
	sed -e "s/timestamp without time zone/DaTETIME DEFAULT (datetime('now','utc'))/g" | \
	# no classes \
	sed -e "s/::[a-zA-Z0-9_]*//g"		| \
	# unsupported options
	sed -e "s/ USING btree/ /g" 		| \
	sed -e "s/\( CHECK.*)\)/-- $1/g"	| \
	# capture midstream to compare \
	#tee pre.sql | \
	# \
	# convert newlines to linefeeds \
	# so sed can process the entire file at once \
	# for multi-line replacements \
	tr '\n' '\f' | \
	sed -e 's/CREATE SEQ[^;]*/ /g'	| \
	sed -e "s/\(ALTER TABLE ONLY[^;]*\)/-- ((($1))) /g" | \
	#tee altered.sql | \
	sed -e $'s/)\\\f;/);/g' 	| \
	# formatting back to normal \
	tr '\f' '\n' 			| \
	# \
	# delete stragglers \
	sed -e $'s/\\\f;//g' 		| \
	# delete other stragglers \
	sed -e 's/^ *; *$//g' 		| \
	# delete empty lines \
	sed -e '/^$/d'
}

# just "CREATE TABLE..." statement
# so we can extract INHERITS info 
# to backfill actual inherited columns
tables() {
	clean | \
		tr '\n' '\f' | \
	       	grep -oE "CREATE T[^;]*" | \
		tr '\f' '\n' 
}

# convert table data to name/DDL k/v format
# NOTE: DDL text '\n' are encoded as '\f'
extract() {
	tables | \
		sed -e "s/\(CREATE TABLE *\)//g" | \
		tr -d '\f'   		| \
		tr -s '\n'   		| \
		tr '\n' '\f' 		| \
		sed -e "s/(/:/g"  	| \
		tr -s '\f'   		| \
		sed -e $'s/)/\\\n/g'  | \
		sed -e "s/^//g"  	| \
		sed -e "s/:/:/g"	| \
		sed -e "s/ *:/:/g"
}

# 'chunk' text into lines that terminate at every ';'
# NOTE: text '\n' are encoded as '\f'
chunk() {
	# ensure no conflict with our separators
	# \f is for newlines within a chunk
	tr -d '\f'   		| \
	# \v is our to be newine \
	tr -d '\v'   		| \
	# remove extra lines 	\
	tr -s '\n'   		| \
	# mark ; at EOL as 	\
	sed -e $'s/;$/;\\\v/g'	| \
	# newlines encoded	\
	tr '\n' '\f' 		| \
	# our previous marker is our new newine \
	tr '\v' '\n' 		| \
	#tee chunky.sql | \
	sed
	#sed -e $'s/);/);\\\n/g'
}

# snip removes all comments
snip() { sed -e "s/--.*//g" ; }

# restore normal line breaks
unchunk() { tr '\f' '\n'; }

# dummy func to test chunking output
fix() {
	# ever line gets a new line before it
	sed -e $'s/^/-- CHUNK\\\n/g'
}

# inherits 'denormalizes' an inherited table
# e.g., it creates a table from parent and child
inherits() {
	# sql in: "CREATE TABLE tblname (contents) INHERITS (src)"
	# sql out: "CREATE TABLE tblname (src, contents)"
	# 
	# on matching statements: "INHERITING\t$tblname\t$contents\t$src"
	#
	# Ugly? Hell yes, but it's written and it works (uh, huh)
	#  $1: tablename
	#  $2: contents
	#  $3: inherit tablename
	#                          1             2                         3          
	#sed -e $"s/.*CREATE TABLE *\([^ ]*\).*INHERITS.*/INHERITING\011\1/g" 
	#sed -e $'s/.*CREATE TABLE *\([^ ]*\).*INHERITS.*/INHERITING: \1/g' 

	# generate a table for cached lookups
	tbl_init
	
	sed -e "s/.*CREATE TABLE *\([^ ]*\)[^(]*(\([^)]*\).*INHERITS[^(]*(\([^)]*\).*/INHERITING::\1::\3::\2/g" | \
	awk \
		-F "::" \
		-v self="$SELF" \
		-v filename="$filename" \
		'
		/^INHERITING/ {
			mycmd = self " -f " filename " lookup " $3;
			mycmd | getline myself
			close(mycmd)
			printf "CREATE TABLE %s (\n    %s,%s);\n", $2, myself, $4; next 
		}
		{ print $0 }
		'
}

final() {
    msg "CONVERTING $filename"
    clean | snip | chunk | inherits | unchunk; exit
}

tbl_init() {
#TODO: make this more flexible
[[ -n $TBLFILE && ! -f $TBLFILE ]] && fail "TBLFILE: $TBLFILE does not exist"
[[ -n $TBLFILE ]] || export TBLFILE=$(mktemp)
msg "tbl_init TBLFILE: $TBLFILE"
extract > $TBLFILE
rm -f tbl.temp
ln -s $TBLFILE tbl.temp
}


lookup() {
	[[ -n $TBLFILE ]] || tbl_init
	msg "looking up: $1 in $TBLFILE"
	#echo "looking up: $1 in $TBLFILE" >> lookup.txt
	grep "$1:" $TBLFILE | sed -e "s/^.*: *//g"
	cp $TBLFILE table.tmp
}

usage() {
	cat << EOF
Usage: $(basename $0) -f filename
EOF
}

while getopts ":f:p:" o; do
    case "${o}" in
        s)
            s=${OPTARG}
            ((s == 45 || s == 90)) || usage
            ;;
        f)
            filename=${OPTARG}
            ;;
        *)
            usage
            ;;
    esac
done
shift $((OPTIND-1))

[[ -z $filename ]] && fail "no filename specified"
[[ -f $filename ]] || fail "filename $filename does not exist"


case $1 in
	'lookup') shift; lookup $1; exit ;;
	'tables') tables; exit ;;
esac

final
